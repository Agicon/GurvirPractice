"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generateId_1 = require("../../common/generateId");
exports.default = (function (original, effect, debug) {
    if (debug === void 0) { debug = false; }
    if (debug) {
        console.log('apply sniffer on', original.name);
    }
    function request(arg0, arg1, arg2) {
        var url;
        var options;
        var callback;
        try {
            if (!arg1 || typeof arg1 === 'function') {
                url = arg0;
                options = arg0;
                callback = arg1;
            }
            else {
                url = arg0;
                options = arg1;
                callback = arg2;
            }
            var id_1 = generateId_1.default();
            effect({ id: id_1, type: 'outgoing', request: Object.assign({}, options, { time: Date.now() }) });
            if (debug) {
                console.log('send request for', id_1);
            }
            var req = original(options, function (res) {
                var httpVersion = res.httpVersion, headers = res.headers, method = res.method, url = res.url, statusCode = res.statusCode, statusMessage = res.statusMessage;
                var buffers = [];
                var strings = [];
                var bufferLength = 0;
                var data = '';
                res.on('data', function (chunk) {
                    if (!Buffer.isBuffer(chunk)) {
                        strings.push(chunk);
                    }
                    else if (chunk.length) {
                        bufferLength += chunk.length;
                        buffers.push(chunk);
                    }
                });
                res.on('end', function () {
                    if (bufferLength) {
                        data = Buffer.concat(buffers, bufferLength).toString('utf8');
                    }
                    else if (strings.length) {
                        if (strings[0].length > 0 && strings[0][0] === '\uFEFF') {
                            strings[0] = strings[0].substring(1);
                        }
                        data = strings.join('');
                    }
                    effect({
                        id: id_1,
                        response: {
                            httpVersion: httpVersion,
                            headers: headers,
                            method: method,
                            url: url,
                            statusCode: statusCode,
                            statusMessage: statusMessage,
                            body: data,
                            time: Date.now(),
                        },
                    });
                    if (debug) {
                        console.log('send response for', id_1);
                    }
                });
                callback && callback(res);
            });
            var originalWrite_1 = req.write;
            var originalEnd_1 = req.end;
            var buffer_1 = '';
            req.write = function (chunk) {
                buffer_1 += chunk;
                return originalWrite_1.apply(this, arguments);
            };
            req.end = function () {
                effect({
                    id: id_1,
                    type: 'outgoing',
                    request: {
                        body: buffer_1,
                    },
                });
                if (debug) {
                    console.log('send request body for', id_1);
                }
                return originalEnd_1.apply(this, arguments);
            };
            return req;
        }
        catch (e) {
            console.error(e);
        }
        if (debug) {
            console.log('use original ', original.name);
        }
        return original(arg0, arg1, arg2);
    }
    return request;
});
//# sourceMappingURL=applyRequestSniffer.js.map